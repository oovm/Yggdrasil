// This file was generated by Peginator v0.2.0
// Hash of the grammar file: F35CDD6F75BE5B804AD458D7EEF0A06E4373F3C85F84AF94D7AC5CD993F3BE77
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct Program {
    pub statement: Vec<Statement>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Statement {
    DefineStatement(DefineStatement),
    EmptyStatement(EmptyStatement),
}
#[derive(Debug, Clone)]
pub struct EmptyStatement;
pub type EOS = String;
#[derive(Debug, Clone)]
pub struct DefineStatement {
    pub define: DEFINE,
    pub modifiers: Modifiers,
    pub symbol: Identifier,
    pub position: std::ops::Range<usize>,
}
pub type DEFINE = String;
#[derive(Debug, Clone)]
pub struct Modifiers {
    pub id: Vec<Identifier>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Choice {
    pub choices: Vec<Sequence>,
}
#[derive(Debug, Clone)]
pub struct Sequence {
    pub items: Vec<Expression>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Expression {
    Charset(Charset),
    Group(Group),
    StringLiteral(StringLiteral),
}
#[derive(Debug, Clone)]
pub struct Group {
    pub body: Choice,
}
#[derive(Debug, Clone)]
pub struct Optional {
    pub body: Choice,
}
#[derive(Debug, Clone)]
pub struct StringLiteral {
    pub body: Vec<StringItem>,
}
pub type StringItem = String;
#[derive(Debug, Clone)]
pub struct Charset {
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Identifier {
    pub identifier: IDENTIFIER,
    pub position: std::ops::Range<usize>,
}
pub type IDENTIFIER = String;
impl peginator_generated::PegParser for Program {
    fn parse_advanced<T: peginator_generated::ParseTracer>(s: &str, settings: &peginator_generated::ParseSettings) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_Program(peginator_generated::ParseState::new(s, settings), T::new(), &mut Default::default())?.result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser};
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod Program_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Statement(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { statement: vec![result] }))
                }
                pub struct Parsed {
                    pub statement: Vec<Statement>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut statement: Vec<Statement> = Vec::new();
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk {
                            result,
                            state: new_state,
                            farthest_error: new_farthest_error,
                        }) => {
                            statement.extend(result.statement);
                            state = new_state;
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                        }
                        Err(err) => {
                            farthest_error = combine_errors(farthest_error, Some(err));
                            break;
                        }
                    }
                }
                Ok(ParseOk { result: Parsed { statement }, state, farthest_error })
            }
            pub struct Parsed {
                pub statement: Vec<Statement>,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                if state.is_empty() { Ok(ParseOk { result: Parsed, state, farthest_error: None }) } else { Err(state.report_error(ParseErrorSpecifics::ExpectedEoi)) }
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let mut statement = result.statement;
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { statement }, state, farthest_error })
        }
        pub struct Parsed {
            pub statement: Vec<Statement>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Program> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|r, new_state| super::Program {
                statement: r.statement,
                position: state.range_until(new_state),
            }))
        }
    }
    #[inline]
    pub(super) fn parse_Program<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Program> {
        tracer.run_traced("Program", state, |state, tracer| Program_impl::rule_parser(state, tracer, cache))
    }
    mod Statement_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_DefineStatement(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { _override: Parsed__override::DefineStatement(result) }))
                }
                pub struct Parsed {
                    pub _override: Parsed__override,
                }
            }
            mod part_1 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_EOS(state, tracer, cache)?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    match optional::parse(state.clone(), tracer, cache) {
                        Ok(ok_result) => Ok(ok_result.map(|result| Parsed {})),
                        Err(err) => Ok(ParseOk { result: Parsed {}, state, farthest_error: Some(err) }),
                    }
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                let result = match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let _override = result._override;
                match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { _override }, state, farthest_error })
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_EmptyStatement(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::EmptyStatement(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::Statement as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Statement> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|result| result._override))
        }
    }
    #[inline]
    pub(super) fn parse_Statement<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Statement> {
        tracer.run_traced("Statement", state, |state, tracer| Statement_impl::rule_parser(state, tracer, cache))
    }
    mod EmptyStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
            let ok_result = parse_EOS(state, tracer, cache)?;
            Ok(ok_result.map(|_| Parsed))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::EmptyStatement> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::EmptyStatement {}))
        }
    }
    #[inline]
    pub(super) fn parse_EmptyStatement<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, EmptyStatement> {
        tracer.run_traced("EmptyStatement", state, |state, tracer| EmptyStatement_impl::rule_parser(state, tracer, cache))
    }
    mod EOS_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ok_result = parse_string_literal(state, ";;")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ok_result = parse_character_literal(state, ';')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, String> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|_, new_state| state.slice_until(new_state).to_string()))
        }
    }
    #[inline]
    pub(super) fn parse_EOS<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, EOS> {
        tracer.run_traced("EOS", state, |state, tracer| EOS_impl::rule_parser(state, tracer, cache))
    }
    mod DefineStatement_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_DEFINE(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { define: result }))
            }
            pub struct Parsed {
                pub define: DEFINE,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Modifiers(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { modifiers: result }))
            }
            pub struct Parsed {
                pub modifiers: Modifiers,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Identifier(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { symbol: result }))
            }
            pub struct Parsed {
                pub symbol: Identifier,
            }
        }
        mod part_3 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '{')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_4 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Choice(state, tracer, cache)?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_5 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '}')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let define = result.define;
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let modifiers = result.modifiers;
            let result = match part_2::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let symbol = result.symbol;
            match part_3::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_4::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_5::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk {
                result: Parsed { define, modifiers, symbol },
                state,
                farthest_error,
            })
        }
        pub struct Parsed {
            pub define: DEFINE,
            pub modifiers: Modifiers,
            pub symbol: Identifier,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::DefineStatement> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|r, new_state| super::DefineStatement {
                define: r.define,
                modifiers: r.modifiers,
                symbol: r.symbol,
                position: state.range_until(new_state),
            }))
        }
    }
    #[inline]
    pub(super) fn parse_DefineStatement<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, DefineStatement> {
        tracer.run_traced("DefineStatement", state, |state, tracer| DefineStatement_impl::rule_parser(state, tracer, cache))
    }
    mod DEFINE_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ok_result = parse_string_literal(state, "def!")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ok_result = parse_string_literal(state, "def")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, String> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|_, new_state| state.slice_until(new_state).to_string()))
        }
    }
    #[inline]
    pub(super) fn parse_DEFINE<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, DEFINE> {
        tracer.run_traced("DEFINE", state, |state, tracer| DEFINE_impl::rule_parser(state, tracer, cache))
    }
    mod Modifiers_impl {
        use super::*;
        mod closure {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Identifier(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { id: vec![result] }))
                }
                pub struct Parsed {
                    pub id: Vec<Identifier>,
                }
            }
            mod part_1 {
                use super::*;
                mod negative_lookahead {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '{')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    match negative_lookahead::parse(state.clone(), tracer, cache) {
                        Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                        Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                    }
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                let result = match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut id = result.id;
                match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { id }, state, farthest_error })
            }
            pub struct Parsed {
                pub id: Vec<Identifier>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut id: Vec<Identifier> = Vec::new();
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        id.extend(result.id);
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed { id }, state, farthest_error })
        }
        pub struct Parsed {
            pub id: Vec<Identifier>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Modifiers> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|r, new_state| super::Modifiers { id: r.id, position: state.range_until(new_state) }))
        }
    }
    #[inline]
    pub(super) fn parse_Modifiers<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Modifiers> {
        tracer.run_traced("Modifiers", state, |state, tracer| Modifiers_impl::rule_parser(state, tracer, cache))
    }
    mod Choice_impl {
        use super::*;
        mod optional {
            use super::*;
            mod part_0 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '|')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    match optional::parse(state.clone(), tracer, cache) {
                        Ok(ok_result) => Ok(ok_result.map(|result| Parsed {})),
                        Err(err) => Ok(ParseOk { result: Parsed {}, state, farthest_error: Some(err) }),
                    }
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Sequence(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { choices: vec![result] }))
                }
                pub struct Parsed {
                    pub choices: Vec<Sequence>,
                }
            }
            mod part_2 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, '|')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_Sequence(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { choices: vec![result] }))
                        }
                        pub struct Parsed {
                            pub choices: Vec<Sequence>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result: _,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut choices = result.choices;
                        Ok(ParseOk { result: Parsed { choices }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub choices: Vec<Sequence>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let mut choices: Vec<Sequence> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                choices.extend(result.choices);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { choices }, state, farthest_error })
                }
                pub struct Parsed {
                    pub choices: Vec<Sequence>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut choices = result.choices;
                let result = match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                choices.extend(result.choices);
                Ok(ParseOk { result: Parsed { choices }, state, farthest_error })
            }
            pub struct Parsed {
                pub choices: Vec<Sequence>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            match optional::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => Ok(ok_result.map(|result| Parsed { choices: result.choices })),
                Err(err) => Ok(ParseOk {
                    result: Parsed { choices: Default::default() },
                    state,
                    farthest_error: Some(err),
                }),
            }
        }
        pub struct Parsed {
            pub choices: Vec<Sequence>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Choice> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::Choice { choices: r.choices }))
        }
    }
    #[inline]
    pub(super) fn parse_Choice<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Choice> {
        tracer.run_traced("Choice", state, |state, tracer| Choice_impl::rule_parser(state, tracer, cache))
    }
    mod Sequence_impl {
        use super::*;
        mod closure {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Expression(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { items: vec![result] }))
            }
            pub struct Parsed {
                pub items: Vec<Expression>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut items: Vec<Expression> = Vec::new();
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        items.extend(result.items);
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed { items }, state, farthest_error })
        }
        pub struct Parsed {
            pub items: Vec<Expression>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Sequence> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::Sequence { items: r.items }))
        }
    }
    #[inline]
    pub(super) fn parse_Sequence<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Sequence> {
        tracer.run_traced("Sequence", state, |state, tracer| Sequence_impl::rule_parser(state, tracer, cache))
    }
    mod Expression_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Group(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::Group(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Charset(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::Charset(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_StringLiteral(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::StringLiteral(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_2::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::Expression as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Expression> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|result| result._override))
        }
    }
    #[inline]
    pub(super) fn parse_Expression<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Expression> {
        tracer.run_traced("Expression", state, |state, tracer| Expression_impl::rule_parser(state, tracer, cache))
    }
    mod Group_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '(')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Choice(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { body: result }))
            }
            pub struct Parsed {
                pub body: Choice,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, ')')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let body = result.body;
            match part_2::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { body }, state, farthest_error })
        }
        pub struct Parsed {
            pub body: Choice,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Group> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::Group { body: r.body }))
        }
    }
    #[inline]
    pub(super) fn parse_Group<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Group> {
        tracer.run_traced("Group", state, |state, tracer| Group_impl::rule_parser(state, tracer, cache))
    }
    mod Optional_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Choice(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { body: result }))
            }
            pub struct Parsed {
                pub body: Choice,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '?')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let body = result.body;
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { body }, state, farthest_error })
        }
        pub struct Parsed {
            pub body: Choice,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Optional> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::Optional { body: r.body }))
        }
    }
    #[inline]
    pub(super) fn parse_Optional<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Optional> {
        tracer.run_traced("Optional", state, |state, tracer| Optional_impl::rule_parser(state, tracer, cache))
    }
    mod StringLiteral_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '"')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                                let ok_result = parse_character_literal(state, '"')?;
                                Ok(ok_result.map(|_| Parsed))
                            }
                            pub struct Parsed;
                        }
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                            }
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            let ok_result = parse_StringItem(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { body: vec![result] }))
                        }
                        pub struct Parsed {
                            pub body: Vec<StringItem>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result: _,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut body = result.body;
                        Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub body: Vec<StringItem>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let mut body: Vec<StringItem> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                body.extend(result.body);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                }
                pub struct Parsed {
                    pub body: Vec<StringItem>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '"')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut body = result.body;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { body }, state, farthest_error })
            }
            pub struct Parsed {
                pub body: Vec<StringItem>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '\'')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                                let ok_result = parse_character_literal(state, '\'')?;
                                Ok(ok_result.map(|_| Parsed))
                            }
                            pub struct Parsed;
                        }
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                            }
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                            let ok_result = parse_StringItem(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { body: vec![result] }))
                        }
                        pub struct Parsed {
                            pub body: Vec<StringItem>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result: _,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut body = result.body;
                        Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub body: Vec<StringItem>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let mut body: Vec<StringItem> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk {
                                result,
                                state: new_state,
                                farthest_error: new_farthest_error,
                            }) => {
                                body.extend(result.body);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                }
                pub struct Parsed {
                    pub body: Vec<StringItem>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '\'')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut body = result.body;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { body }, state, farthest_error })
            }
            pub struct Parsed {
                pub body: Vec<StringItem>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { body: result.body })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { body: result.body })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub body: Vec<StringItem>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::StringLiteral> {
            let ok_result = parse(state, tracer, cache)?;
            Ok(ok_result.map(|r| super::StringLiteral { body: r.body }))
        }
    }
    #[inline]
    pub(super) fn parse_StringLiteral<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, StringLiteral> {
        tracer.run_traced("StringLiteral", state, |state, tracer| StringLiteral_impl::rule_parser(state, tracer, cache))
    }
    mod StringItem_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '\\')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_char(state, tracer, cache)?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk {
                        result: _,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed {}, state, farthest_error })
            }
            pub struct Parsed;
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ok_result = parse_char(state, tracer, cache)?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, String> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|_, new_state| state.slice_until(new_state).to_string()))
        }
    }
    #[inline]
    pub(super) fn parse_StringItem<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, StringItem> {
        tracer.run_traced("StringItem", state, |state, tracer| StringItem_impl::rule_parser(state, tracer, cache))
    }
    mod Charset_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '[')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, ']')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk {
                    result: _,
                    state: new_state,
                    farthest_error: new_farthest_error,
                }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed {}, state, farthest_error })
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Charset> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|r, new_state| super::Charset { position: state.range_until(new_state) }))
        }
    }
    #[inline]
    pub(super) fn parse_Charset<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Charset> {
        tracer.run_traced("Charset", state, |state, tracer| Charset_impl::rule_parser(state, tracer, cache))
    }
    mod Identifier_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
            let ok_result = parse_IDENTIFIER(state, tracer, cache)?;
            Ok(ok_result.map(|result| Parsed { identifier: result }))
        }
        pub struct Parsed {
            pub identifier: IDENTIFIER,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, super::Identifier> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|r, new_state| super::Identifier {
                identifier: r.identifier,
                position: state.range_until(new_state),
            }))
        }
    }
    #[inline]
    pub(super) fn parse_Identifier<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Identifier> {
        tracer.run_traced("Identifier", state, |state, tracer| Identifier_impl::rule_parser(state, tracer, cache))
    }
    mod IDENTIFIER_impl {
        use super::*;
        mod closure {
            use super::*;
            mod choice_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_range(state, 'a', 'z')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod choice_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_range(state, 'A', 'Z')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod choice_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '_')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod choice_3 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_range(state, '0', '9')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match choice_0::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_1::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_2::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_3::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, Parsed> {
            let ParseOk { result, mut state, mut farthest_error } = closure::parse(state, tracer, cache)?;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk {
                        result,
                        state: new_state,
                        farthest_error: new_farthest_error,
                    }) => {
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed {}, state, farthest_error })
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, String> {
            let ok_result = parse(state.clone(), tracer, cache)?;
            Ok(ok_result.map_with_state(|_, new_state| state.slice_until(new_state).to_string()))
        }
    }
    #[inline]
    pub(super) fn parse_IDENTIFIER<'a>(state: ParseState<'a>, tracer: impl ParseTracer, cache: &mut ParseCache<'a>) -> ParseResult<'a, IDENTIFIER> {
        tracer.run_traced("IDENTIFIER", state, |state, tracer| IDENTIFIER_impl::rule_parser(state, tracer, cache))
    }
}

// This file was generated by Peginator v0.2.6
// Hash of the grammar file: 52B077EEB151E167B08258C8D45BEF58C56DE84CD9E2898ABA7393DA4E270E5E
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct ProgramParser {
    pub program: ProgramNode,
}
#[derive(Debug, Clone)]
pub struct ProgramNode {
    pub statements: Vec<StatementNode>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StatementNode {
    DefineStatement(DefineStatement),
    EmptyStatement(EmptyStatement),
}
#[derive(Debug, Clone)]
pub struct EmptyStatement;
pub type EOS = char;
#[derive(Debug, Clone)]
pub struct DefineStatement {
    pub define: DEFINE,
    pub modifiers: Modifiers,
    pub symbol: Identifier,
    pub arguments: Option<Arguments>,
    pub r#type: Option<Typing>,
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
pub type DEFINE = String;
#[derive(Debug, Clone)]
pub struct MacroCalls {
    pub macros: Vec<Macro>,
}
#[derive(Debug, Clone)]
pub struct Macro {
    pub id: Identifier,
    pub args: Option<ArgumentValue>,
}
pub type Boolean = String;
pub type ArgumentValue = String;
#[derive(Debug, Clone)]
pub struct Modifiers {
    pub id: Vec<Identifier>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ChoiceNode {
    pub terms: Vec<Term>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Term {
    pub prefix: Vec<Prefix>,
    pub tag: Option<Identifier>,
    pub node: Node,
    pub suffix: Vec<Suffix>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Arguments {
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Typing {
    pub id: Identifier,
    pub position: std::ops::Range<usize>,
}
pub type Prefix = char;
pub type Suffix = char;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum Node {
    CharsetNode(CharsetNode),
    Group(Group),
    Identifier(Identifier),
    StringLiteral(StringLiteral),
}
#[derive(Debug, Clone)]
pub struct Group {
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct StringLiteral {
    pub body: Vec<StringItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    CharOne(CharOne),
    StringEscaped(StringEscaped),
}
#[derive(Debug, Clone)]
pub struct StringEscaped {
    pub char: char,
}
#[derive(Debug, Clone)]
pub struct CharsetNode {
    pub items: Vec<CharItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum CharItem {
    CharOne(CharOne),
    CharRange(CharRange),
}
#[derive(Debug, Clone)]
pub struct CharRange {
    pub start: char,
    pub end: char,
    pub position: std::ops::Range<usize>,
}
pub type CharOne = char;
#[derive(Debug, Clone)]
pub struct Identifier {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
impl peginator_generated::PegParser for ProgramParser {
    fn parse_advanced<T: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_ProgramParser(
            peginator_generated::ParseState::new(s, settings),
            T::new(),
            &mut Default::default(),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::runtime::*;
    pub use peginator::runtime::{IndentedTracer, ParseError, ParseSettings, ParseState, ParseTracer, PegParser, PegPosition};
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod ProgramParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_ProgramNode(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { program: result }))
            }
            pub struct Parsed {
                pub program: ProgramNode,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                if state.is_empty() {
                    Ok(ParseOk { result: Parsed, state, farthest_error: None })
                }
                else {
                    Err(state.report_error(ParseErrorSpecifics::ExpectedEoi))
                }
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let program = result.program;
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { program }, state, farthest_error })
        }
        pub struct Parsed {
            pub program: ProgramNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ProgramParser> {
            let result = parse(state, tracer, cache)?.map(|r| super::ProgramParser { program: r.program });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ProgramParser<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ProgramParser> {
        tracer.run_traced("ProgramParser", state, |state, tracer| ProgramParser_impl::rule_parser(state, tracer, cache))
    }
    mod ProgramNode_impl {
        use super::*;
        mod closure {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_StatementNode(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { statements: vec![result] }))
            }
            pub struct Parsed {
                pub statements: Vec<StatementNode>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut statements: Vec<StatementNode> = Vec::new();
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        statements.extend(result.statements);
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed { statements }, state, farthest_error })
        }
        pub struct Parsed {
            pub statements: Vec<StatementNode>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ProgramNode> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::ProgramNode {
                statements: r.statements,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ProgramNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ProgramNode> {
        tracer.run_traced("ProgramNode", state, |state, tracer| ProgramNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for ProgramNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StatementNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_DefineStatement(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { _override: Parsed__override::DefineStatement(result) }))
                }
                pub struct Parsed {
                    pub _override: Parsed__override,
                }
            }
            mod part_1 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_EOS(state, tracer, cache)?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    match optional::parse(state.clone(), tracer, cache) {
                        Ok(ok_result) => Ok(ok_result.map(|result| Parsed {})),
                        Err(err) => Ok(ParseOk { result: Parsed {}, state, farthest_error: Some(err) }),
                    }
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                let result = match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let _override = result._override;
                match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { _override }, state, farthest_error })
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_EmptyStatement(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::EmptyStatement(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::StatementNode as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StatementNode> {
            let result = parse(state, tracer, cache)?.map(|result| result._override);
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StatementNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StatementNode> {
        tracer.run_traced("StatementNode", state, |state, tracer| StatementNode_impl::rule_parser(state, tracer, cache))
    }
    mod EmptyStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
            let ok_result = parse_EOS(state, tracer, cache)?;
            Ok(ok_result.map(|_| Parsed))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::EmptyStatement> {
            let result = parse(state, tracer, cache)?.map(|r| super::EmptyStatement {});
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_EmptyStatement<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, EmptyStatement> {
        tracer.run_traced("EmptyStatement", state, |state, tracer| EmptyStatement_impl::rule_parser(state, tracer, cache))
    }
    #[inline]
    pub(super) fn parse_EOS<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, EOS> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "EOS" }))
    }
    mod DefineStatement_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_MacroCalls(state, tracer, cache)?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_DEFINE(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { define: result }))
            }
            pub struct Parsed {
                pub define: DEFINE,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Modifiers(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { modifiers: result }))
            }
            pub struct Parsed {
                pub modifiers: Modifiers,
            }
        }
        mod part_3 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Identifier(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { symbol: result }))
            }
            pub struct Parsed {
                pub symbol: Identifier,
            }
        }
        mod part_4 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Arguments(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { arguments: Some(result) }))
                }
                pub struct Parsed {
                    pub arguments: Option<Arguments>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                match optional::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => Ok(ok_result.map(|result| Parsed { arguments: result.arguments })),
                    Err(err) => {
                        Ok(ParseOk { result: Parsed { arguments: Default::default() }, state, farthest_error: Some(err) })
                    }
                }
            }
            pub struct Parsed {
                pub arguments: Option<Arguments>,
            }
        }
        mod part_5 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Typing(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { r#type: Some(result) }))
                }
                pub struct Parsed {
                    pub r#type: Option<Typing>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                match optional::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => Ok(ok_result.map(|result| Parsed { r#type: result.r#type })),
                    Err(err) => Ok(ParseOk { result: Parsed { r#type: Default::default() }, state, farthest_error: Some(err) }),
                }
            }
            pub struct Parsed {
                pub r#type: Option<Typing>,
            }
        }
        mod part_6 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '{')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_7 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_ChoiceNode(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { body: result }))
            }
            pub struct Parsed {
                pub body: ChoiceNode,
            }
        }
        mod part_8 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '}')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let define = result.define;
            let result = match part_2::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let modifiers = result.modifiers;
            let result = match part_3::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let symbol = result.symbol;
            let result = match part_4::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let arguments = result.arguments;
            let result = match part_5::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let r#type = result.r#type;
            match part_6::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_7::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let body = result.body;
            match part_8::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { define, modifiers, symbol, arguments, r#type, body }, state, farthest_error })
        }
        pub struct Parsed {
            pub define: DEFINE,
            pub modifiers: Modifiers,
            pub symbol: Identifier,
            pub arguments: Option<Arguments>,
            pub r#type: Option<Typing>,
            pub body: ChoiceNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::DefineStatement> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::DefineStatement {
                define: r.define,
                modifiers: r.modifiers,
                symbol: r.symbol,
                arguments: r.arguments,
                r#type: r.r#type,
                body: r.body,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DefineStatement<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DefineStatement> {
        tracer.run_traced("DefineStatement", state, |state, tracer| DefineStatement_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for DefineStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DEFINE_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ok_result = parse_string_literal(state, "def!")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ok_result = parse_string_literal(state, "def")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, DEFINE> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_DEFINE<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, DEFINE> {
        tracer.run_traced("DEFINE", state, |state, tracer| DEFINE_impl::rule_parser(state, tracer, cache))
    }
    mod MacroCalls_impl {
        use super::*;
        mod closure {
            use super::*;
            mod choice_0 {
                use super::*;
                mod part_0 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '#')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                mod part_1 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_Macro(state, tracer, cache)?;
                        Ok(ok_result.map(|result| Parsed { macros: vec![result] }))
                    }
                    pub struct Parsed {
                        pub macros: Vec<Macro>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    match part_0::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    let result = match part_1::parse(state, tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                            result
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    };
                    let mut macros = result.macros;
                    Ok(ParseOk { result: Parsed { macros }, state, farthest_error })
                }
                pub struct Parsed {
                    pub macros: Vec<Macro>,
                }
            }
            mod choice_1 {
                use super::*;
                mod part_0 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '#')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                mod part_1 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '[')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                mod part_2 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_Macro(state, tracer, cache)?;
                        Ok(ok_result.map(|result| Parsed { macros: vec![result] }))
                    }
                    pub struct Parsed {
                        pub macros: Vec<Macro>,
                    }
                }
                mod part_3 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, ']')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    match part_0::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    match part_1::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    let result = match part_2::parse(state, tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                            result
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    };
                    let mut macros = result.macros;
                    match part_3::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    Ok(ParseOk { result: Parsed { macros }, state, farthest_error })
                }
                pub struct Parsed {
                    pub macros: Vec<Macro>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match choice_0::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { macros: result.macros })),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_1::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { macros: result.macros })),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
            }
            pub struct Parsed {
                pub macros: Vec<Macro>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut macros: Vec<Macro> = Vec::new();
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        macros.extend(result.macros);
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed { macros }, state, farthest_error })
        }
        pub struct Parsed {
            pub macros: Vec<Macro>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::MacroCalls> {
            let result = parse(state, tracer, cache)?.map(|r| super::MacroCalls { macros: r.macros });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_MacroCalls<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, MacroCalls> {
        tracer.run_traced("MacroCalls", state, |state, tracer| MacroCalls_impl::rule_parser(state, tracer, cache))
    }
    mod Macro_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Identifier(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { id: result }))
            }
            pub struct Parsed {
                pub id: Identifier,
            }
        }
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                mod part_0 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '(')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                mod part_1 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_ArgumentValue(state, tracer, cache)?;
                        Ok(ok_result.map(|result| Parsed { args: Some(result) }))
                    }
                    pub struct Parsed {
                        pub args: Option<ArgumentValue>,
                    }
                }
                mod part_2 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, ')')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    match part_0::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    let result = match part_1::parse(state, tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                            result
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    };
                    let args = result.args;
                    match part_2::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    Ok(ParseOk { result: Parsed { args }, state, farthest_error })
                }
                pub struct Parsed {
                    pub args: Option<ArgumentValue>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                match optional::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => Ok(ok_result.map(|result| Parsed { args: result.args })),
                    Err(err) => Ok(ParseOk { result: Parsed { args: Default::default() }, state, farthest_error: Some(err) }),
                }
            }
            pub struct Parsed {
                pub args: Option<ArgumentValue>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let id = result.id;
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let args = result.args;
            Ok(ParseOk { result: Parsed { id, args }, state, farthest_error })
        }
        pub struct Parsed {
            pub id: Identifier,
            pub args: Option<ArgumentValue>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Macro> {
            let result = parse(state, tracer, cache)?.map(|r| super::Macro { id: r.id, args: r.args });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Macro<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Macro> {
        tracer.run_traced("Macro", state, |state, tracer| Macro_impl::rule_parser(state, tracer, cache))
    }
    mod Boolean_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_string_literal(state, "true")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_string_literal(state, "false")?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Boolean> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Boolean<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Boolean> {
        tracer.run_traced("Boolean", state, |state, tracer| Boolean_impl::rule_parser(state, tracer, cache))
    }
    mod ArgumentValue_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
            let ok_result = parse_Boolean(state, tracer, cache)?;
            Ok(ok_result.map(|result| Parsed { _override: result }))
        }
        pub struct Parsed {
            pub _override: Boolean,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, ArgumentValue> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ArgumentValue<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ArgumentValue> {
        tracer.run_traced("ArgumentValue", state, |state, tracer| ArgumentValue_impl::rule_parser(state, tracer, cache))
    }
    mod Modifiers_impl {
        use super::*;
        mod closure {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Identifier(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { id: vec![result] }))
                }
                pub struct Parsed {
                    pub id: Vec<Identifier>,
                }
            }
            mod part_1 {
                use super::*;
                mod negative_lookahead {
                    use super::*;
                    mod choice_0 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, '{')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod choice_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, '(')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod choice_2 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, ':')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod choice_3 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_string_literal(state, "->")?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod choice_4 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, ';')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match choice_0::parse(state.clone(), tracer, cache) {
                            Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                            Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                        }
                        match choice_1::parse(state.clone(), tracer, cache) {
                            Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                            Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                        }
                        match choice_2::parse(state.clone(), tracer, cache) {
                            Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                            Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                        }
                        match choice_3::parse(state.clone(), tracer, cache) {
                            Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                            Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                        }
                        match choice_4::parse(state.clone(), tracer, cache) {
                            Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                            Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                        }
                        Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    match negative_lookahead::parse(state.clone(), tracer, cache) {
                        Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                        Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                    }
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                let result = match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut id = result.id;
                match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { id }, state, farthest_error })
            }
            pub struct Parsed {
                pub id: Vec<Identifier>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut id: Vec<Identifier> = Vec::new();
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            loop {
                match closure::parse(state.clone(), tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        id.extend(result.id);
                        state = new_state;
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                    }
                    Err(err) => {
                        farthest_error = combine_errors(farthest_error, Some(err));
                        break;
                    }
                }
            }
            Ok(ParseOk { result: Parsed { id }, state, farthest_error })
        }
        pub struct Parsed {
            pub id: Vec<Identifier>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Modifiers> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::Modifiers { id: r.id, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Modifiers<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Modifiers> {
        tracer.run_traced("Modifiers", state, |state, tracer| Modifiers_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Modifiers {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ChoiceNode_impl {
        use super::*;
        mod optional {
            use super::*;
            mod part_0 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, '|')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    match optional::parse(state.clone(), tracer, cache) {
                        Ok(ok_result) => Ok(ok_result.map(|result| Parsed {})),
                        Err(err) => Ok(ParseOk { result: Parsed {}, state, farthest_error: Some(err) }),
                    }
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Term(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { terms: vec![result] }))
                }
                pub struct Parsed {
                    pub terms: Vec<Term>,
                }
            }
            mod part_2 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_character_literal(state, '|')?;
                            Ok(ok_result.map(|_| Parsed))
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                            let ok_result = parse_Term(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { terms: vec![result] }))
                        }
                        pub struct Parsed {
                            pub terms: Vec<Term>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut terms = result.terms;
                        Ok(ParseOk { result: Parsed { terms }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub terms: Vec<Term>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut terms: Vec<Term> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                terms.extend(result.terms);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { terms }, state, farthest_error })
                }
                pub struct Parsed {
                    pub terms: Vec<Term>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut terms = result.terms;
                let result = match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                terms.extend(result.terms);
                Ok(ParseOk { result: Parsed { terms }, state, farthest_error })
            }
            pub struct Parsed {
                pub terms: Vec<Term>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            match optional::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => Ok(ok_result.map(|result| Parsed { terms: result.terms })),
                Err(err) => Ok(ParseOk { result: Parsed { terms: Default::default() }, state, farthest_error: Some(err) }),
            }
        }
        pub struct Parsed {
            pub terms: Vec<Term>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::ChoiceNode> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::ChoiceNode { terms: r.terms, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_ChoiceNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, ChoiceNode> {
        tracer.run_traced("ChoiceNode", state, |state, tracer| ChoiceNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for ChoiceNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Term_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Prefix(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { prefix: vec![result] }))
                }
                pub struct Parsed {
                    pub prefix: Vec<Prefix>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut prefix: Vec<Prefix> = Vec::new();
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            prefix.extend(result.prefix);
                            state = new_state;
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                        }
                        Err(err) => {
                            farthest_error = combine_errors(farthest_error, Some(err));
                            break;
                        }
                    }
                }
                Ok(ParseOk { result: Parsed { prefix }, state, farthest_error })
            }
            pub struct Parsed {
                pub prefix: Vec<Prefix>,
            }
        }
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                mod part_0 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_Identifier(state, tracer, cache)?;
                        Ok(ok_result.map(|result| Parsed { tag: Some(result) }))
                    }
                    pub struct Parsed {
                        pub tag: Option<Identifier>,
                    }
                }
                mod part_1 {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                        let ok_result = parse_character_literal(state, ':')?;
                        Ok(ok_result.map(|_| Parsed))
                    }
                    pub struct Parsed;
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    let result = match part_0::parse(state, tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                            result
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    };
                    let tag = result.tag;
                    match part_1::parse(state, tracer, cache) {
                        Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                            state = new_state;
                        }
                        Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                    }
                    Ok(ParseOk { result: Parsed { tag }, state, farthest_error })
                }
                pub struct Parsed {
                    pub tag: Option<Identifier>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                match optional::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => Ok(ok_result.map(|result| Parsed { tag: result.tag })),
                    Err(err) => Ok(ParseOk { result: Parsed { tag: Default::default() }, state, farthest_error: Some(err) }),
                }
            }
            pub struct Parsed {
                pub tag: Option<Identifier>,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Node(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { node: result }))
            }
            pub struct Parsed {
                pub node: Node,
            }
        }
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_Suffix(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { suffix: vec![result] }))
                }
                pub struct Parsed {
                    pub suffix: Vec<Suffix>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut suffix: Vec<Suffix> = Vec::new();
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            suffix.extend(result.suffix);
                            state = new_state;
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                        }
                        Err(err) => {
                            farthest_error = combine_errors(farthest_error, Some(err));
                            break;
                        }
                    }
                }
                Ok(ParseOk { result: Parsed { suffix }, state, farthest_error })
            }
            pub struct Parsed {
                pub suffix: Vec<Suffix>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let mut prefix = result.prefix;
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let tag = result.tag;
            let result = match part_2::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let node = result.node;
            let result = match part_3::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let mut suffix = result.suffix;
            Ok(ParseOk { result: Parsed { prefix, tag, node, suffix }, state, farthest_error })
        }
        pub struct Parsed {
            pub prefix: Vec<Prefix>,
            pub tag: Option<Identifier>,
            pub node: Node,
            pub suffix: Vec<Suffix>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Term> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::Term {
                prefix: r.prefix,
                tag: r.tag,
                node: r.node,
                suffix: r.suffix,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Term<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Term> {
        tracer.run_traced("Term", state, |state, tracer| Term_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Term {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Arguments_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '(')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, ')')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed {}, state, farthest_error })
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Arguments> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::Arguments { position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Arguments<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Arguments> {
        tracer.run_traced("Arguments", state, |state, tracer| Arguments_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Arguments {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Typing_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod choice_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_string_literal(state, "->")?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod choice_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_character_literal(state, ':')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match choice_0::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_1::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Identifier(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { id: result }))
            }
            pub struct Parsed {
                pub id: Identifier,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let id = result.id;
            Ok(ParseOk { result: Parsed { id }, state, farthest_error })
        }
        pub struct Parsed {
            pub id: Identifier,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Typing> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::Typing { id: r.id, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Typing<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Typing> {
        tracer.run_traced("Typing", state, |state, tracer| Typing_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Typing {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_Prefix<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Prefix> {
        if let Ok(result) = parse_character_literal(state.clone(), '^') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '!') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Prefix" }))
    }
    #[inline]
    pub(super) fn parse_Suffix<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Suffix> {
        if let Ok(result) = parse_character_literal(state.clone(), '+') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '*') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '?') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Suffix" }))
    }
    mod Node_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Group(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::Group(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_CharsetNode(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::CharsetNode(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_StringLiteral(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::StringLiteral(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_3 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_Identifier(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::Identifier(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_2::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_3::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::Node as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Node> {
            let result = parse(state, tracer, cache)?.map(|result| result._override);
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Node<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Node> {
        tracer.run_traced("Node", state, |state, tracer| Node_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Node {
        fn position(&self) -> &std::ops::Range<usize> {
            match self {
                Self::CharsetNode(x) => x.position(),
                Self::Group(x) => x.position(),
                Self::Identifier(x) => x.position(),
                Self::StringLiteral(x) => x.position(),
            }
        }
    }
    mod Group_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '(')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_ChoiceNode(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { body: result }))
            }
            pub struct Parsed {
                pub body: ChoiceNode,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, ')')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let body = result.body;
            match part_2::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { body }, state, farthest_error })
        }
        pub struct Parsed {
            pub body: ChoiceNode,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::Group> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::Group { body: r.body, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Group<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Group> {
        tracer.run_traced("Group", state, |state, tracer| Group_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Group {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringLiteral_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '"')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(
                                state: ParseState<'a>,
                                tracer: impl ParseTracer,
                                cache: &mut ParseCache<'a>,
                            ) -> ParseResult<'a, Parsed> {
                                let ok_result = parse_character_literal(state, '"')?;
                                Ok(ok_result.map(|_| Parsed))
                            }
                            pub struct Parsed;
                        }
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                            }
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ok_result = parse_StringItem(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { body: vec![result] }))
                        }
                        pub struct Parsed {
                            pub body: Vec<StringItem>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut body = result.body;
                        Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub body: Vec<StringItem>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut body: Vec<StringItem> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                body.extend(result.body);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                }
                pub struct Parsed {
                    pub body: Vec<StringItem>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '"')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut body = result.body;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { body }, state, farthest_error })
            }
            pub struct Parsed {
                pub body: Vec<StringItem>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '\'')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a>(
                                state: ParseState<'a>,
                                tracer: impl ParseTracer,
                                cache: &mut ParseCache<'a>,
                            ) -> ParseResult<'a, Parsed> {
                                let ok_result = parse_character_literal(state, '\'')?;
                                Ok(ok_result.map(|_| Parsed))
                            }
                            pub struct Parsed;
                        }
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), tracer, cache) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: Parsed, state, farthest_error: None }),
                            }
                        }
                        pub struct Parsed;
                    }
                    mod part_1 {
                        use super::*;
                        #[inline(always)]
                        pub fn parse<'a>(
                            state: ParseState<'a>,
                            tracer: impl ParseTracer,
                            cache: &mut ParseCache<'a>,
                        ) -> ParseResult<'a, Parsed> {
                            let ok_result = parse_StringItem(state, tracer, cache)?;
                            Ok(ok_result.map(|result| Parsed { body: vec![result] }))
                        }
                        pub struct Parsed {
                            pub body: Vec<StringItem>,
                        }
                    }
                    #[inline(always)]
                    pub fn parse<'a>(
                        state: ParseState<'a>,
                        tracer: impl ParseTracer,
                        cache: &mut ParseCache<'a>,
                    ) -> ParseResult<'a, Parsed> {
                        let mut state = state;
                        let mut farthest_error: Option<ParseError> = None;
                        match part_0::parse(state, tracer, cache) {
                            Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        }
                        let result = match part_1::parse(state, tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                                state = new_state;
                                result
                            }
                            Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                        };
                        let mut body = result.body;
                        Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                    }
                    pub struct Parsed {
                        pub body: Vec<StringItem>,
                    }
                }
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let mut body: Vec<StringItem> = Vec::new();
                    let mut state = state;
                    let mut farthest_error: Option<ParseError> = None;
                    loop {
                        match closure::parse(state.clone(), tracer, cache) {
                            Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                                body.extend(result.body);
                                state = new_state;
                                farthest_error = combine_errors(farthest_error, new_farthest_error);
                            }
                            Err(err) => {
                                farthest_error = combine_errors(farthest_error, Some(err));
                                break;
                            }
                        }
                    }
                    Ok(ParseOk { result: Parsed { body }, state, farthest_error })
                }
                pub struct Parsed {
                    pub body: Vec<StringItem>,
                }
            }
            mod part_2 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '\'')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match part_0::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                let result = match part_1::parse(state, tracer, cache) {
                    Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                        result
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                };
                let mut body = result.body;
                match part_2::parse(state, tracer, cache) {
                    Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                        farthest_error = combine_errors(farthest_error, new_farthest_error);
                        state = new_state;
                    }
                    Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
                }
                Ok(ParseOk { result: Parsed { body }, state, farthest_error })
            }
            pub struct Parsed {
                pub body: Vec<StringItem>,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { body: result.body })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { body: result.body })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub body: Vec<StringItem>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StringLiteral> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::StringLiteral { body: r.body, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StringLiteral<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StringLiteral> {
        tracer.run_traced("StringLiteral", state, |state, tracer| StringLiteral_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for StringLiteral {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringItem_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ok_result = parse_StringEscaped(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::StringEscaped(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ok_result = parse_CharOne(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::CharOne(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::StringItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StringItem> {
            let result = parse(state, tracer, cache)?.map(|result| result._override);
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StringItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StringItem> {
        tracer.run_traced("StringItem", state, |state, tracer| StringItem_impl::rule_parser(state, tracer, cache))
    }
    mod StringEscaped_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '\\')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_char(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { char: result }))
            }
            pub struct Parsed {
                pub char: char,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let char = result.char;
            Ok(ParseOk { result: Parsed { char }, state, farthest_error })
        }
        pub struct Parsed {
            pub char: char,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::StringEscaped> {
            let result = parse(state, tracer, cache)?.map(|r| super::StringEscaped { char: r.char });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_StringEscaped<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, StringEscaped> {
        tracer.run_traced("StringEscaped", state, |state, tracer| StringEscaped_impl::rule_parser(state, tracer, cache))
    }
    mod CharsetNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '[')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                    let ok_result = parse_CharItem(state, tracer, cache)?;
                    Ok(ok_result.map(|result| Parsed { items: vec![result] }))
                }
                pub struct Parsed {
                    pub items: Vec<CharItem>,
                }
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut items: Vec<CharItem> = Vec::new();
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            items.extend(result.items);
                            state = new_state;
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                        }
                        Err(err) => {
                            farthest_error = combine_errors(farthest_error, Some(err));
                            break;
                        }
                    }
                }
                Ok(ParseOk { result: Parsed { items }, state, farthest_error })
            }
            pub struct Parsed {
                pub items: Vec<CharItem>,
            }
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, ']')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let mut items = result.items;
            match part_2::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed { items }, state, farthest_error })
        }
        pub struct Parsed {
            pub items: Vec<CharItem>,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::CharsetNode> {
            let result = parse(state.clone(), tracer, cache)?
                .map_with_state(|r, new_state| super::CharsetNode { items: r.items, position: state.range_until(new_state) });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_CharsetNode<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, CharsetNode> {
        tracer.run_traced("CharsetNode", state, |state, tracer| CharsetNode_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for CharsetNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod CharItem_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_CharRange(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::CharRange(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        mod choice_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_CharOne(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { _override: Parsed__override::CharOne(result) }))
            }
            pub struct Parsed {
                pub _override: Parsed__override,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match choice_0::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            match choice_1::parse(state.clone(), tracer, cache) {
                Ok(ok_result) => return Ok(ok_result.map(|result| Parsed { _override: result._override })),
                Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
            }
            Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
        }
        pub struct Parsed {
            pub _override: Parsed__override,
        }
        use super::CharItem as Parsed__override;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::CharItem> {
            let result = parse(state, tracer, cache)?.map(|result| result._override);
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_CharItem<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, CharItem> {
        tracer.run_traced("CharItem", state, |state, tracer| CharItem_impl::rule_parser(state, tracer, cache))
    }
    mod CharRange_impl {
        use super::*;
        mod part_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_char(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { start: result }))
            }
            pub struct Parsed {
                pub start: char,
            }
        }
        mod part_1 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_character_literal(state, '-')?;
                Ok(ok_result.map(|_| Parsed))
            }
            pub struct Parsed;
        }
        mod part_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, tracer, cache)?;
                let ok_result = parse_char(state, tracer, cache)?;
                Ok(ok_result.map(|result| Parsed { end: result }))
            }
            pub struct Parsed {
                pub end: char,
            }
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            let result = match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let start = result.start;
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            let result = match part_2::parse(state, tracer, cache) {
                Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                    result
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            };
            let end = result.end;
            Ok(ParseOk { result: Parsed { start, end }, state, farthest_error })
        }
        pub struct Parsed {
            pub start: char,
            pub end: char,
        }
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, super::CharRange> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|r, new_state| super::CharRange {
                start: r.start,
                end: r.end,
                position: state.range_until(new_state),
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_CharRange<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, CharRange> {
        tracer.run_traced("CharRange", state, |state, tracer| CharRange_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for CharRange {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_CharOne<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, CharOne> {
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "CharOne" }))
    }
    mod Identifier_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod choice_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_XID_START(state, tracer, cache)?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            mod choice_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_character_literal(state, '_')?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                match choice_0::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                match choice_1::parse(state.clone(), tracer, cache) {
                    Ok(ok_result) => return Ok(ok_result.map(|result| Parsed)),
                    Err(err) => farthest_error = combine_errors(farthest_error, Some(err)),
                }
                Err(farthest_error.unwrap_or_else(|| state.report_error(ParseErrorSpecifics::Other)))
            }
            pub struct Parsed;
        }
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a>(
                    state: ParseState<'a>,
                    tracer: impl ParseTracer,
                    cache: &mut ParseCache<'a>,
                ) -> ParseResult<'a, Parsed> {
                    let ok_result = parse_XID_CONTINUE(state, tracer, cache)?;
                    Ok(ok_result.map(|_| Parsed))
                }
                pub struct Parsed;
            }
            #[inline(always)]
            pub fn parse<'a>(
                state: ParseState<'a>,
                tracer: impl ParseTracer,
                cache: &mut ParseCache<'a>,
            ) -> ParseResult<'a, Parsed> {
                let mut state = state;
                let mut farthest_error: Option<ParseError> = None;
                loop {
                    match closure::parse(state.clone(), tracer, cache) {
                        Ok(ParseOk { result, state: new_state, farthest_error: new_farthest_error }) => {
                            state = new_state;
                            farthest_error = combine_errors(farthest_error, new_farthest_error);
                        }
                        Err(err) => {
                            farthest_error = combine_errors(farthest_error, Some(err));
                            break;
                        }
                    }
                }
                Ok(ParseOk { result: Parsed {}, state, farthest_error })
            }
            pub struct Parsed;
        }
        #[inline(always)]
        pub fn parse<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Parsed> {
            let mut state = state;
            let mut farthest_error: Option<ParseError> = None;
            match part_0::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            match part_1::parse(state, tracer, cache) {
                Ok(ParseOk { result: _, state: new_state, farthest_error: new_farthest_error }) => {
                    farthest_error = combine_errors(farthest_error, new_farthest_error);
                    state = new_state;
                }
                Err(err) => return Err(combine_errors(farthest_error, Some(err)).unwrap()),
            }
            Ok(ParseOk { result: Parsed {}, state, farthest_error })
        }
        pub struct Parsed;
        #[inline(always)]
        pub fn rule_parser<'a>(
            state: ParseState<'a>,
            tracer: impl ParseTracer,
            cache: &mut ParseCache<'a>,
        ) -> ParseResult<'a, Identifier> {
            let result = parse(state.clone(), tracer, cache)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Identifier { string, position: state.range_until(new_state) }
            });
            Ok(result)
        }
    }
    #[inline]
    pub(super) fn parse_Identifier<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, Identifier> {
        tracer.run_traced("Identifier", state, |state, tracer| Identifier_impl::rule_parser(state, tracer, cache))
    }
    impl PegPosition for Identifier {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_xid::UnicodeXID::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a>(
        state: ParseState<'a>,
        tracer: impl ParseTracer,
        cache: &mut ParseCache<'a>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_xid::UnicodeXID::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), tracer, cache) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
}

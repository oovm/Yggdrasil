@export

ProgramParser = program:ProgramNode $;

@position
ProgramNode = {statements:StatementNode};

StatementNode =
    @:DefineStatement [EOS]
  | @:EmptyStatement
  ;

EmptyStatement = EOS;

@char
EOS = ';';

@position
DefineStatement = MacroCalls define:DEFINE modifiers:Modifiers symbol:Identifier [arguments:Arguments] [type:Typing] '{' body:ChoiceNode '}';

@string
@no_skip_ws
DEFINE = 'def!' | 'def';


MacroCalls =
    { '#' macros:Macro
    | '#' '[' macros:Macro ']'
    };
Macro = id:Identifier ['(' args:ArgumentValue ')'];

@string
Boolean = 'true' | 'false';

@string
ArgumentValue =
    @:Boolean;

@position
Modifiers = {id:Identifier !('{'|'('|':'|'->'|';')};

@position
ChoiceNode = [['|'] terms:Term {"|" terms:Term}];

@position
Term = {prefix:Prefix} [tag:Identifier ':'] node:Node {suffix:Suffix};

@position
Arguments = '(' ')';

@position
Typing = ('->' | ':') id:Identifier;

@char
Prefix = '^' | '!';

@char
Suffix = '+' | '*' | '?';

@position
Node =
    @:Group |
    @:Charset |
    @:StringLiteral |
    @:Identifier
    ;
@position
Group = "(" body:ChoiceNode ")";

@position
@no_skip_ws
StringLiteral =
    '"' {!'"' body:StringItem } '"' |
    "'" {!"'" body:StringItem } "'"
    ;

@no_skip_ws
StringItem =
    @:StringEscaped |
    @:CharOne
    ;

StringEscaped = '\\' char:char;

@position
Charset = '[' {CharItem} ']';

CharItem =
    @:CharRange |
    @:CharOne
    ;
@position
CharRange = start:char '-' end:char;
@char
CharOne = char;

@position
@string
@no_skip_ws
Identifier = (XID_START | '_') {XID_CONTINUE};


@char
@check(unicode_xid::UnicodeXID::is_xid_start)
XID_START = char;


@char
@check(unicode_xid::UnicodeXID::is_xid_continue)
XID_CONTINUE = char;

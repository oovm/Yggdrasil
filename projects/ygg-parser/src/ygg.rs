// This file was generated by Peginator v0.6.0 built at 1676280617
// CRC-32/ISO-HDLC of the grammar file: de009a8e
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct ProgramParser {
    pub program: ProgramNode,
}
#[derive(Debug, Clone)]
pub struct ProgramNode {
    pub statements: Vec<StatementNode>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StatementNode {
    ClassStatement(ClassStatement),
    EmptyStatement(EmptyStatement),
    UnionStatement(UnionStatement),
}
#[derive(Debug, Clone)]
pub struct EmptyStatement;
pub type EOS = char;
#[derive(Debug, Clone)]
pub struct DefineStatement {
    pub define: DefineNode,
    pub modifiers: Modifiers,
    pub symbol: Identifier,
    pub arguments: Option<Arguments>,
    pub r#type: Option<Typing>,
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
pub type DefineNode = String;
#[derive(Debug, Clone)]
pub struct ClassStatement {
    pub modifiers: Modifiers,
    pub symbol: Identifier,
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct UnionStatement {
    pub modifiers: Modifiers,
    pub symbol: Identifier,
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct KW_CLASS;
#[derive(Debug, Clone)]
pub struct KW_UNION;
#[derive(Debug, Clone)]
pub struct MacroCalls {
    pub macros: Vec<Macro>,
}
#[derive(Debug, Clone)]
pub struct Macro {
    pub id: Identifier,
    pub args: Option<ArgumentValue>,
}
pub type Boolean = String;
pub type ArgumentValue = String;
#[derive(Debug, Clone)]
pub struct Modifiers {
    pub id: Vec<Identifier>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ChoiceNode {
    pub terms: Vec<ExprStream>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ExprStream {
    CharsetNode(CharsetNode),
    Group(Group),
    Identifier(Identifier),
    Infix(Infix),
    Prefix(Prefix),
    StringLiteral(StringLiteral),
    Suffix(Suffix),
}
#[derive(Debug, Clone)]
pub struct Prefix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Suffix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Infix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Arguments {
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Typing {
    pub id: Identifier,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Group {
    pub body: ChoiceNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct StringLiteral {
    pub body: Vec<StringItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    CharOne(CharOne),
    StringEscaped(StringEscaped),
}
#[derive(Debug, Clone)]
pub struct StringEscaped {
    pub char: char,
}
#[derive(Debug, Clone)]
pub struct CharsetNode {
    pub neg: Option<CharsetNeg>,
    pub items: Vec<CharItem>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct CharsetNeg;
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum CharItem {
    CharOne(CharOne),
    CharRange(CharRange),
}
#[derive(Debug, Clone)]
pub struct CharRange {
    pub start: char,
    pub end: char,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct CharOne {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Identifier {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
impl peginator_generated::PegParserAdvanced<()> for ProgramParser {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_defined: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_ProgramParser(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_defined,
            ),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser, PegParserAdvanced,
        PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod ProgramParser_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: program, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ProgramNode(state, &mut *global))?;
            let ParseOk { state, .. } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: program, state })
        }
        pub type Parsed = ProgramNode;
    }
    #[inline]
    pub(super) fn parse_ProgramParser<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ProgramParser> {
        global.tracer.print_trace_start(&state, "ProgramParser");
        let result = {
            let result = ProgramParser_impl::parse(state, global)?.map(|r| super::ProgramParser { program: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ProgramNode_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut statements: Vec<StatementNode> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_StatementNode(state, &mut *global))
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        statements.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<StatementNode>;
    }
    #[inline]
    pub(super) fn parse_ProgramNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ProgramNode> {
        global.tracer.print_trace_start(&state, "ProgramNode");
        let result = {
            let result = ProgramNode_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::ProgramNode { statements: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ProgramNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StatementNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ClassStatement(state, global))
                        .map_inner(Parsed__override::ClassStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_UnionStatement(state, global))
                        .map_inner(Parsed__override::UnionStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_EmptyStatement(state, global))
                        .map_inner(Parsed__override::EmptyStatement)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StatementNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_StatementNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StatementNode> {
        global.tracer.print_trace_start(&state, "StatementNode");
        let result = {
            let result = StatementNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod EmptyStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_EOS(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_EmptyStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EmptyStatement> {
        global.tracer.print_trace_start(&state, "EmptyStatement");
        let result = {
            let result = EmptyStatement_impl::parse(state, global)?.map(|r| super::EmptyStatement {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    #[inline]
    pub(super) fn parse_EOS<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, EOS> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "EOS" }))
    }
    mod DefineStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_MacroCalls(state, &mut *global))
                .discard_result()?;
            let ParseOk { result: define, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DefineNode(state, &mut *global))?;
            let ParseOk { result: modifiers, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Modifiers(state, &mut *global))?;
            let ParseOk { result: symbol, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { result: arguments, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Arguments(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: r#type, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Typing(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ChoiceNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { define, modifiers, symbol, arguments, r#type, body }, state })
        }
        pub struct Parsed {
            pub define: DefineNode,
            pub modifiers: Modifiers,
            pub symbol: Identifier,
            pub arguments: Option<Arguments>,
            pub r#type: Option<Typing>,
            pub body: ChoiceNode,
        }
    }
    #[inline]
    pub(super) fn parse_DefineStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineStatement> {
        global.tracer.print_trace_start(&state, "DefineStatement");
        let result = {
            let result =
                DefineStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::DefineStatement {
                    define: r.define,
                    modifiers: r.modifiers,
                    symbol: r.symbol,
                    arguments: r.arguments,
                    r#type: r.r#type,
                    body: r.body,
                    position: state.range_until(new_state),
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for DefineStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DefineNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| parse_string_literal(state, "def").discard_result())
                .choice(|state| parse_string_literal(state, "union").discard_result())
                .choice(|state| parse_string_literal(state, "class").discard_result())
                .choice(|state| parse_string_literal(state, "enum").discard_result())
                .choice(|state| parse_string_literal(state, "struct").discard_result())
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_DefineNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineNode> {
        global.tracer.print_trace_start(&state, "DefineNode");
        let result = {
            let result = DefineNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ClassStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: modifiers, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Modifiers(state, &mut *global))?;
            let ParseOk { result: symbol, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ChoiceNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { modifiers, symbol, body }, state })
        }
        pub struct Parsed {
            pub modifiers: Modifiers,
            pub symbol: Identifier,
            pub body: ChoiceNode,
        }
    }
    #[inline]
    pub(super) fn parse_ClassStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ClassStatement> {
        global.tracer.print_trace_start(&state, "ClassStatement");
        let result = {
            let result =
                ClassStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::ClassStatement {
                    modifiers: r.modifiers,
                    symbol: r.symbol,
                    body: r.body,
                    position: state.range_until(new_state),
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ClassStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod UnionStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: modifiers, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Modifiers(state, &mut *global))?;
            let ParseOk { result: symbol, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ChoiceNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { modifiers, symbol, body }, state })
        }
        pub struct Parsed {
            pub modifiers: Modifiers,
            pub symbol: Identifier,
            pub body: ChoiceNode,
        }
    }
    #[inline]
    pub(super) fn parse_UnionStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, UnionStatement> {
        global.tracer.print_trace_start(&state, "UnionStatement");
        let result = {
            let result =
                UnionStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::UnionStatement {
                    modifiers: r.modifiers,
                    symbol: r.symbol,
                    body: r.body,
                    position: state.range_until(new_state),
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for UnionStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod KW_CLASS_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "class"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "struct"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_KW_CLASS<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KW_CLASS> {
        global.tracer.print_trace_start(&state, "KW_CLASS");
        let result = {
            let result = KW_CLASS_impl::parse(state, global)?.map(|r| super::KW_CLASS {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KW_UNION_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "union"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "enum"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_KW_UNION<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KW_UNION> {
        global.tracer.print_trace_start(&state, "KW_UNION");
        let result = {
            let result = KW_UNION_impl::parse(state, global)?.map(|r| super::KW_UNION {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod MacroCalls_impl {
        use super::*;
        mod closure {
            use super::*;
            mod choice_0 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '#'))
                        .discard_result()?;
                    let ParseOk { result: mut macros, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Macro(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: macros, state })
                }
                pub type Parsed = Vec<Macro>;
            }
            mod choice_1 {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '#'))
                        .discard_result()?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                        .discard_result()?;
                    let ParseOk { result: mut macros, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Macro(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                        .discard_result()?;
                    Ok(ParseOk { result: macros, state })
                }
                pub type Parsed = Vec<Macro>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                ChoiceHelper::new(state)
                    .choice(|state| choice_0::parse(state, global))
                    .choice(|state| choice_1::parse(state, global))
                    .end()
            }
            pub type Parsed = Vec<Macro>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut macros: Vec<Macro> = Vec::new();
            loop {
                match closure::parse(state.clone(), global) {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        macros.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: macros, state })
        }
        pub type Parsed = Vec<Macro>;
    }
    #[inline]
    pub(super) fn parse_MacroCalls<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, MacroCalls> {
        global.tracer.print_trace_start(&state, "MacroCalls");
        let result = {
            let result = MacroCalls_impl::parse(state, global)?.map(|r| super::MacroCalls { macros: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Macro_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                        .discard_result()?;
                    let ParseOk { result: args, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ArgumentValue(state, &mut *global))
                        .map_inner(Some)?;
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                        .discard_result()?;
                    Ok(ParseOk { result: args, state })
                }
                pub type Parsed = Option<ArgumentValue>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ArgumentValue>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: id, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            let ParseOk { result: args, state } = part_1::parse(state, global)?;
            Ok(ParseOk { result: Parsed { id, args }, state })
        }
        pub struct Parsed {
            pub id: Identifier,
            pub args: Option<ArgumentValue>,
        }
    }
    #[inline]
    pub(super) fn parse_Macro<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Macro> {
        global.tracer.print_trace_start(&state, "Macro");
        let result = {
            let result = Macro_impl::parse(state, global)?.map(|r| super::Macro { id: r.id, args: r.args });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Boolean_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Boolean<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Boolean> {
        global.tracer.print_trace_start(&state, "Boolean");
        let result = {
            let result = Boolean_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ArgumentValue_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Boolean(state, global))
        }
        pub type Parsed = Boolean;
    }
    #[inline]
    pub(super) fn parse_ArgumentValue<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ArgumentValue> {
        global.tracer.print_trace_start(&state, "ArgumentValue");
        let result = {
            let result = ArgumentValue_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Modifiers_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut id: Vec<Identifier> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk { result: __result, state: new_state, .. }) => {
                        id.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: id, state })
        }
        pub type Parsed = Vec<Identifier>;
    }
    #[inline]
    pub(super) fn parse_Modifiers<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Modifiers> {
        global.tracer.print_trace_start(&state, "Modifiers");
        let result = {
            let result = Modifiers_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::Modifiers { id: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Modifiers {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ChoiceNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut terms: Vec<ExprStream> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExprStream(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            terms.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: terms, state })
            }
            pub type Parsed = Vec<ExprStream>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '|'))
                .discard_result()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            let ParseOk { result: mut terms, state } = part_1::parse(state, global)?;
            Ok(ParseOk { result: terms, state })
        }
        pub type Parsed = Vec<ExprStream>;
    }
    #[inline]
    pub(super) fn parse_ChoiceNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ChoiceNode> {
        global.tracer.print_trace_start(&state, "ChoiceNode");
        let result = {
            let result = ChoiceNode_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::ChoiceNode { terms: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ChoiceNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ExprStream_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Prefix(state, global))
                        .map_inner(Parsed__override::Prefix)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Suffix(state, global))
                        .map_inner(Parsed__override::Suffix)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Infix(state, global))
                        .map_inner(Parsed__override::Infix)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharsetNode(state, global))
                        .map_inner(Parsed__override::CharsetNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringLiteral(state, global))
                        .map_inner(Parsed__override::StringLiteral)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Identifier(state, global))
                        .map_inner(Parsed__override::Identifier)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Group(state, global))
                        .map_inner(Parsed__override::Group)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ExprStream as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_ExprStream<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExprStream> {
        global.tracer.print_trace_start(&state, "ExprStream");
        let result = {
            let result = ExprStream_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Prefix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '^'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Prefix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Prefix> {
        global.tracer.print_trace_start(&state, "Prefix");
        let result = {
            let result = Prefix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Prefix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Prefix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Suffix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '*'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '?'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Suffix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Suffix> {
        global.tracer.print_trace_start(&state, "Suffix");
        let result = {
            let result = Suffix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Suffix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Suffix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Infix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '|'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '~'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Infix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Infix> {
        global.tracer.print_trace_start(&state, "Infix");
        let result = {
            let result = Infix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Infix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Infix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Arguments_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Arguments<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Arguments> {
        global.tracer.print_trace_start(&state, "Arguments");
        let result = {
            let result = Arguments_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::Arguments { position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Arguments {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Typing_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "->"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()
                })
                .end()?;
            let ParseOk { result: id, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Identifier(state, &mut *global))?;
            Ok(ParseOk { result: id, state })
        }
        pub type Parsed = Identifier;
    }
    #[inline]
    pub(super) fn parse_Typing<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Typing> {
        global.tracer.print_trace_start(&state, "Typing");
        let result = {
            let result = Typing_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::Typing { id: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Typing {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Group_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk { result: body, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ChoiceNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk { result: body, state })
        }
        pub type Parsed = ChoiceNode;
    }
    #[inline]
    pub(super) fn parse_Group<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Group> {
        global.tracer.print_trace_start(&state, "Group");
        let result = {
            let result = Group_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::Group { body: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Group {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringLiteral_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_character_literal(state, '"').discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut body, state } =
                            parse_StringItem(state, &mut *global).map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: body, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut body: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                body.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: body, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
                let ParseOk { result: mut body, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_character_literal(state, '"').discard_result()?;
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_character_literal(state, '\'').discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut body, state } =
                            parse_StringItem(state, &mut *global).map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: body, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut body: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                body.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: body, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_literal(state, '\'').discard_result()?;
                let ParseOk { result: mut body, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_character_literal(state, '\'').discard_result()?;
                Ok(ParseOk { result: body, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<StringItem>;
    }
    #[inline]
    pub(super) fn parse_StringLiteral<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringLiteral> {
        global.tracer.print_trace_start(&state, "StringLiteral");
        let result = {
            let result = StringLiteral_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::StringLiteral { body: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for StringLiteral {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| parse_StringEscaped(state, global).map_inner(Parsed__override::StringEscaped))
                .choice(|state| parse_CharOne(state, global).map_inner(Parsed__override::CharOne))
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StringItem as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_StringItem<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringItem> {
        global.tracer.print_trace_start(&state, "StringItem");
        let result = {
            let result = StringItem_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod StringEscaped_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { result: char, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))?;
            Ok(ParseOk { result: char, state })
        }
        pub type Parsed = char;
    }
    #[inline]
    pub(super) fn parse_StringEscaped<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringEscaped> {
        global.tracer.print_trace_start(&state, "StringEscaped");
        let result = {
            let result = StringEscaped_impl::parse(state, global)?.map(|r| super::StringEscaped { char: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharsetNode_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut items: Vec<CharItem> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharItem(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            items.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: items, state })
            }
            pub type Parsed = Vec<CharItem>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                .discard_result()?;
            let ParseOk { result: neg, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CharsetNeg(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: mut items, state } = part_2::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                .discard_result()?;
            Ok(ParseOk { result: Parsed { neg, items }, state })
        }
        pub struct Parsed {
            pub neg: Option<CharsetNeg>,
            pub items: Vec<CharItem>,
        }
    }
    #[inline]
    pub(super) fn parse_CharsetNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharsetNode> {
        global.tracer.print_trace_start(&state, "CharsetNode");
        let result =
            {
                let result = CharsetNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| {
                    super::CharsetNode { neg: r.neg, items: r.items, position: state.range_until(new_state) }
                });
                Ok(result)
            };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for CharsetNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod CharsetNeg_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '^'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_CharsetNeg<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharsetNeg> {
        global.tracer.print_trace_start(&state, "CharsetNeg");
        let result = {
            let result = CharsetNeg_impl::parse(state, global)?.map(|r| super::CharsetNeg {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharRange(state, global))
                        .map_inner(Parsed__override::CharRange)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_CharOne(state, global))
                        .map_inner(Parsed__override::CharOne)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::CharItem as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_CharItem<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharItem> {
        global.tracer.print_trace_start(&state, "CharItem");
        let result = {
            let result = CharItem_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CharRange_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: start, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                .discard_result()?;
            let ParseOk { result: end, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { start, end }, state })
        }
        pub struct Parsed {
            pub start: char,
            pub end: char,
        }
    }
    #[inline]
    pub(super) fn parse_CharRange<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharRange> {
        global.tracer.print_trace_start(&state, "CharRange");
        let result = {
            let result = CharRange_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::CharRange {
                start: r.start,
                end: r.end,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for CharRange {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod CharOne_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_char(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_CharOne<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CharOne> {
        global.tracer.print_trace_start(&state, "CharOne");
        let result = {
            let result = CharOne_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                CharOne { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for CharOne {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Identifier_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_XID_CONTINUE(state.clone(), &mut *global).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_XID_START(state, &mut *global).discard_result())
                .choice(|state| parse_character_literal(state, '_').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Identifier<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Identifier> {
        global.tracer.print_trace_start(&state, "Identifier");
        let result = {
            let result = Identifier_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Identifier { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Identifier {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_xid::UnicodeXID::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_xid::UnicodeXID::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
}

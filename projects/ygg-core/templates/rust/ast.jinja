#![allow(unused_variables)]
use super::*;

{%- set rules = self.grammar.rules() %}
{%- set rule_name = self.grammar.rule_name() %}
{%- set parser_name = self.grammar.parser_name() %}

{%- for rule in rules.clone() %}
#[automatically_derived]
impl<'i> YggdrasilNode<'i> for {{ rule.node_name() }}<'i> {
    type Rule = {{ self.grammar.rule_name() }};

    fn from_str(input: &'i str, offset: usize) -> Result<Self, YggdrasilError<Self::Rule>> {
        Self::from_cst({{ parser_name }}::parse_cst(input, {{ rule_name }}::{{ rule.name.text|safe_rust_id }})?)
    }
    fn from_pair(pair: TokenPair<'i, Self::Rule>) -> Result<Self, YggdrasilError<Self::Rule>> {
{%- if rule.is_class() %}
        Ok(Self { pair })
{%- else if rule.is_union() %}
        let _span = pair.get_span();
{%- for (variant, class) in rule.union_fields() %}
        if let Ok(s) = pair.take_tagged_one("{{ variant|snake_case }}") {
            return Ok(Self::{{ variant }}(s));
        }
{%- endfor %}
        Err(YggdrasilError::invalid_node({{ self.grammar.rule_name() }}::{{ rule.name.text|safe_rust_id }}, _span))
{%- endif %}
    }

    fn get_rule(&self) -> Self::Rule {
        {{ rule_name }}::{{ rule.name.text|safe_rust_id }}
    }

    fn get_str(&self) -> &'i str {
{%- if rule.is_class() %}
        self.pair.get_span().as_str()
{%- else %}
        match self {
{%- for (variant, class) in rule.union_fields() %}
            Self::{{ variant }}(s) => s.get_str(),
{%- endfor %}
        }
{%- endif %}
    }

    fn get_range(&self) -> Range<usize> {
{%- if rule.is_class() %}
        self.pair.get_span().get_range()
{%- else %}
        match self {
{%- for (variant, class) in rule.union_fields() %}
            Self::{{ variant }}(s) => s.get_range(),
{%- endfor %}
        }
{%- endif %}
    }
}
{%- if rule.is_class() %}
impl<'i> {{ rule.node_name() }}<'i> {
{%- for field in rule.class_fields() %}
{%- if field.count.is_one() %}
    pub fn {{ field.field_name() }}(&self) -> {{ field.field_type(self.grammar) }}<'i> {
        self.pair.take_tagged_one("{{ field.field_name() }}").unwrap()
{%- else if field.count.is_optional() %}
    pub fn {{ field.field_name() }}(&self) -> Option<{{ field.field_type(self.grammar) }}<'i>> {
        self.pair.take_tagged_option("{{ field.field_name() }}")
{%- else %}
    pub fn {{ field.field_name() }}(&self) -> Vec<{{ field.field_type(self.grammar) }}<'i>> {
        self.pair.take_tagged_items("{{ field.field_name() }}").collect::<Result<Vec<_>, _>>().unwrap()
{%- endif %}
    }
{%- endfor %}
}
{%- endif %}
{%- endfor %}

